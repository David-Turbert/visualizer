{"version":3,"sources":["jcampconverter.min.js"],"names":["e","exports","module","define","amd","f","window","global","self","JcampConverter","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"getConverter","convertToFloatArray","stringArray","floatArray","Array","parseFloat","convert","jcamp","options","ldr","dataLabel","dataValue","ldrs","ii","position","endLine","infos","start","Date","ntuples","result","profiling","logs","spectra","info","spectrum","push","action","time","split","replace","indexOf","substring","trim","toUpperCase","xIndex","yIndex","firstVariable","secondVariable","symbol","first","firstX","firstY","last","lastX","lastY","vardim","nbPoints","factor","xFactor","yFactor","units","xUnit","yUnit","datatable","deltaX","title","dataType","twoD","observeFrequency","xType","indirectFrequency","shiftOffsetNum","shiftOffsetVal","varname","vartype","varform","min","max","yType","page","pageValue","pageSymbol","pageSymbolIndex","unit","prepareSpectrum","match","parseXYData","parsePeakTable","isMSField","convertMSFieldToLabel","add2D","keepSpectra","toLowerCase","addGCMS","value","GC_MS_FIELDS","existingGCMSFields","label","gcms","gc","ms","j","data","shift","jj","values","currentData","lines","k","removeCommentRegExp","peakTableSplitRegExp","lastDif","ascii","currentX","currentY","xyDataSplitRegExp","DEBUG","firstPoint","expectedCurrentX","charCodeAt","String","fromCharCode","dup","convertTo3DZ","z","noise","minZ","maxZ","ySize","xSize","Math","abs","minX","maxX","minY","maxY","zData","contourLines","generateContourLines","minMax","pAx","pAy","pBx","pBy","lineZValue","contourLevels","nbLevels","povarHeight","Float32Array","isOver","nbSubSpectra","nbPovars","x0","xN","dx","y0","yN","dy","level","contourLevel","side","exp","zValue","iSubSpectra","povar","segments","input","useWorker","postToWorker","worker","createWorker","Promise","resolve","stamp","now","random","stamps","postMessage","workerURL","URL","createObjectURL","Blob","toString","type","Worker","revokeObjectURL","addEventListener","event","output"],"mappings":"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","file":"jcampconverter.min.js","sourcesContent":["/**\n * jcampconverter - Parse and convert JCAMP data\n * @version v2.0.4\n * @link https://github.com/cheminfo/jcampconverter\n * @license MIT\n */\n!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.JcampConverter=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nfunction getConverter() {\n\n    // the following RegExp can only be used for XYdata, some peakTables have values with a \"E-5\" ...\n    var xyDataSplitRegExp = /[,\\t \\+-]*(?=[^\\d,\\t \\.])|[ \\t]+(?=[\\d+\\.-])/;\n    var removeCommentRegExp = /\\$\\$.*/;\n    var peakTableSplitRegExp = /[,\\t ]+/;\n    var DEBUG = false;\n\n    var GC_MS_FIELDS = ['TIC', '.RIC', 'SCANNUMBER'];\n\n    function convertToFloatArray(stringArray) {\n        var l = stringArray.length;\n        var floatArray = new Array(l);\n        for (var i = 0; i < l; i++) {\n            floatArray[i] = parseFloat(stringArray[i]);\n        }\n        return floatArray;\n    }\n\n    /*\n     options.keepSpectra: keep the original spectra for a 2D\n     */\n\n    function convert(jcamp, options) {\n        options = options || {};\n        var start = new Date();\n\n        var ntuples = {},\n            ldr,\n            dataLabel,\n            dataValue,\n            ldrs,\n            i, ii, position, endLine, infos;\n\n        var result = {};\n        result.profiling = [];\n        result.logs = [];\n        var spectra = [];\n        result.spectra = spectra;\n        result.info = {};\n        var spectrum = {};\n\n        if (!(typeof jcamp == 'string')) return result;\n        // console.time('start');\n\n        if (result.profiling) result.profiling.push({action: 'Before split to LDRS', time: new Date() - start});\n\n        ldrs = jcamp.split(/[\\r\\n]+##/);\n\n        if (result.profiling) result.profiling.push({action: 'Split to LDRS', time: new Date() - start});\n\n        if (ldrs[0]) ldrs[0] = ldrs[0].replace(/^[\\r\\n ]*##/, '');\n\n        for (i = 0, ii = ldrs.length; i < ii; i++) {\n            ldr = ldrs[i];\n            // This is a new LDR\n            position = ldr.indexOf('=');\n            if (position > 0) {\n                dataLabel = ldr.substring(0, position);\n                dataValue = ldr.substring(position + 1).trim();\n            } else {\n                dataLabel = ldr;\n                dataValue = '';\n            }\n            dataLabel = dataLabel.replace(/[_ -]/g, '').toUpperCase();\n\n            if (dataLabel == 'DATATABLE') {\n\n                endLine = dataValue.indexOf('\\n');\n                if (endLine == -1) endLine = dataValue.indexOf('\\r');\n                if (endLine > 0) {\n                    var xIndex = -1;\n                    var yIndex = -1;\n                    // ##DATA TABLE= (X++(I..I)), XYDATA\n                    // We need to find the variables\n\n                    infos = dataValue.substring(0, endLine).split(/[ ,;\\t]+/);\n\n                    if (infos[0].indexOf('++') > 0) {\n                        var firstVariable = infos[0].replace(/.*\\(([a-zA-Z0-9]+)\\+\\+.*/, '$1');\n                        var secondVariable = infos[0].replace(/.*\\.\\.([a-zA-Z0-9]+).*/, '$1');\n                        xIndex = ntuples.symbol.indexOf(firstVariable);\n                        yIndex = ntuples.symbol.indexOf(secondVariable);\n                    }\n\n                    if (xIndex == -1) xIndex = 0;\n                    if (yIndex == -1) yIndex = 0;\n\n                    if (ntuples.first) {\n                        if (ntuples.first.length > xIndex) spectrum.firstX = ntuples.first[xIndex];\n                        if (ntuples.first.length > yIndex) spectrum.firstY = ntuples.first[yIndex];\n                    }\n                    if (ntuples.last) {\n                        if (ntuples.last.length > xIndex) spectrum.lastX = ntuples.last[xIndex];\n                        if (ntuples.last.length > yIndex) spectrum.lastY = ntuples.last[yIndex];\n                    }\n                    if (ntuples.vardim && ntuples.vardim.length > xIndex) {\n                        spectrum.nbPoints = ntuples.vardim[xIndex];\n                    }\n                    if (ntuples.factor) {\n                        if (ntuples.factor.length > xIndex) spectrum.xFactor = ntuples.factor[xIndex];\n                        if (ntuples.factor.length > yIndex) spectrum.yFactor = ntuples.factor[yIndex];\n                    }\n                    if (ntuples.units) {\n                        if (ntuples.units.length > xIndex) spectrum.xUnit = ntuples.units[xIndex];\n                        if (ntuples.units.length > yIndex) spectrum.yUnit = ntuples.units[yIndex];\n                    }\n                    spectrum.datatable = infos[0];\n                    if (infos[1] && infos[1].indexOf('PEAKS') > -1) {\n                        dataLabel = 'PEAKTABLE';\n                    } else if (infos[1] && (infos[1].indexOf('XYDATA') || infos[0].indexOf('++') > 0)) {\n                        dataLabel = 'XYDATA';\n                        spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n                    }\n                }\n            }\n\n\n            if (dataLabel == 'TITLE') {\n                spectrum.title = dataValue;\n            } else if (dataLabel == 'DATATYPE') {\n                spectrum.dataType = dataValue;\n                if (dataValue.indexOf('nD') > -1) {\n                    result.twoD = true;\n                }\n            } else if (dataLabel == 'XUNITS') {\n                spectrum.xUnit = dataValue;\n            } else if (dataLabel == 'YUNITS') {\n                spectrum.yUnit = dataValue;\n            } else if (dataLabel == 'FIRSTX') {\n                spectrum.firstX = parseFloat(dataValue);\n            } else if (dataLabel == 'LASTX') {\n                spectrum.lastX = parseFloat(dataValue);\n            } else if (dataLabel == 'FIRSTY') {\n                spectrum.firstY = parseFloat(dataValue);\n            } else if (dataLabel == 'NPOINTS') {\n                spectrum.nbPoints = parseFloat(dataValue);\n            } else if (dataLabel == 'XFACTOR') {\n                spectrum.xFactor = parseFloat(dataValue);\n            } else if (dataLabel == 'YFACTOR') {\n                spectrum.yFactor = parseFloat(dataValue);\n            } else if (dataLabel == 'DELTAX') {\n                spectrum.deltaX = parseFloat(dataValue);\n            } else if (dataLabel == '.OBSERVEFREQUENCY' || dataLabel == '$SFO1') {\n                if (!spectrum.observeFrequency) spectrum.observeFrequency = parseFloat(dataValue);\n            } else if (dataLabel == '.OBSERVENUCLEUS') {\n                if (!spectrum.xType) result.xType = dataValue.replace(/[^a-zA-Z0-9]/g, '');\n            } else if (dataLabel == '$SFO2') {\n                if (!result.indirectFrequency) result.indirectFrequency = parseFloat(dataValue);\n\n            } else if (dataLabel == '$OFFSET') {   // OFFSET for Bruker spectra\n                result.shiftOffsetNum = 0;\n                if (!result.shiftOffsetVal)  result.shiftOffsetVal = parseFloat(dataValue);\n            } else if (dataLabel == '$REFERENCEPOINT') {   // OFFSET for Varian spectra\n\n\n                // if we activate this part it does not work for ACD specmanager\n                //         } else if (dataLabel=='.SHIFTREFERENCE') {   // OFFSET FOR Bruker Spectra\n                //                 var parts = dataValue.split(/ *, */);\n                //                 result.shiftOffsetNum = parseInt(parts[2].trim());\n                //                 result.shiftOffsetVal = parseFloat(parts[3].trim());\n            } else if (dataLabel == 'VARNAME') {\n                ntuples.varname = dataValue.split(/[, \\t]+/);\n            } else if (dataLabel == 'SYMBOL') {\n                ntuples.symbol = dataValue.split(/[, \\t]+/);\n            } else if (dataLabel == 'VARTYPE') {\n                ntuples.vartype = dataValue.split(/[, \\t]+/);\n            } else if (dataLabel == 'VARFORM') {\n                ntuples.varform = dataValue.split(/[, \\t]+/);\n            } else if (dataLabel == 'VARDIM') {\n                ntuples.vardim = convertToFloatArray(dataValue.split(/[, \\t]+/));\n            } else if (dataLabel == 'UNITS') {\n                ntuples.units = dataValue.split(/[, \\t]+/);\n            } else if (dataLabel == 'FACTOR') {\n                ntuples.factor = convertToFloatArray(dataValue.split(/[, \\t]+/));\n            } else if (dataLabel == 'FIRST') {\n                ntuples.first = convertToFloatArray(dataValue.split(/[, \\t]+/));\n            } else if (dataLabel == 'LAST') {\n                ntuples.last = convertToFloatArray(dataValue.split(/[, \\t]+/));\n            } else if (dataLabel == 'MIN') {\n                ntuples.min = convertToFloatArray(dataValue.split(/[, \\t]+/));\n            } else if (dataLabel == 'MAX') {\n                ntuples.max = convertToFloatArray(dataValue.split(/[, \\t]+/));\n            } else if (dataLabel == '.NUCLEUS') {\n                if (result.twoD) {\n                    result.yType = dataValue.split(/[, \\t]+/)[0];\n                }\n            } else if (dataLabel == 'PAGE') {\n                spectrum.page = dataValue.trim();\n                spectrum.pageValue = parseFloat(dataValue.replace(/^.*=/, ''));\n                spectrum.pageSymbol = spectrum.page.replace(/=.*/, '');\n                var pageSymbolIndex = ntuples.symbol.indexOf(spectrum.pageSymbol);\n                var unit = '';\n                if (ntuples.units && ntuples.units[pageSymbolIndex]) {\n                    unit = ntuples.units[pageSymbolIndex];\n                }\n                if (result.indirectFrequency && unit != 'PPM') {\n                    spectrum.pageValue /= result.indirectFrequency;\n                }\n            } else if (dataLabel == 'RETENTIONTIME') {\n                spectrum.pageValue = parseFloat(dataValue);\n            } else if (dataLabel == 'XYDATA') {\n                prepareSpectrum(result, spectrum);\n                // well apparently we should still consider it is a PEAK TABLE if there are no '++' after\n                if (dataValue.match(/.*\\+\\+.*/)) {\n                    parseXYData(spectrum, dataValue, result);\n                } else {\n                    parsePeakTable(spectrum, dataValue, result);\n                }\n                spectra.push(spectrum);\n                spectrum = {};\n            } else if (dataLabel == 'PEAKTABLE') {\n                prepareSpectrum(result, spectrum);\n                parsePeakTable(spectrum, dataValue, result);\n                spectra.push(spectrum);\n                spectrum = {};\n            } else if (isMSField(dataLabel)) {\n                spectrum[convertMSFieldToLabel(dataLabel)] = dataValue;\n            } else if (dataLabel.match(/^[A-Z].*/)) {\n                result.info[dataLabel] = dataValue.trim();\n            }\n        }\n\n        // Currently disabled\n        //    if (options && options.lowRes) addLowRes(spectra,options);\n\n        if (result.profiling) result.profiling.push({action: 'Finished parsing', time: new Date() - start});\n\n        if (result.twoD) {\n            add2D(result);\n            if (result.profiling) result.profiling.push({\n                action: 'Finished countour plot calculation',\n                time: new Date() - start\n            });\n            if (!options.keepSpectra) {\n                delete result.spectra;\n            }\n        }\n\n\n        // maybe it is a GC (HPLC) / MS. In this case we add a new format\n        if (spectra.length > 1 && spectra[0].dataType.toLowerCase().match(/.*mass./)) {\n            addGCMS(result);\n            if (result.profiling) result.profiling.push({\n                action: 'Finished GCMS calculation',\n                time: new Date() - start\n            });\n        }\n\n        if (result.profiling) {\n            result.profiling.push({action: 'Total time', time: new Date() - start});\n        }\n\n        //   console.log(result);\n        //    console.log(JSON.stringify(spectra));\n        return result;\n\n    }\n\n\n    function convertMSFieldToLabel(value) {\n        return value.toLowerCase().replace(/[^a-z0-9]/g, '');\n    }\n\n    function isMSField(dataLabel) {\n        for (var i = 0; i < GC_MS_FIELDS.length; i++) {\n            if (dataLabel == GC_MS_FIELDS[i]) return true;\n        }\n        return false;\n    }\n\n    function addGCMS(result) {\n        var spectra = result.spectra;\n        var existingGCMSFields = [];\n        var i;\n        for (i = 0; i < GC_MS_FIELDS.length; i++) {\n            var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n            if (spectra[0][label]) {\n                existingGCMSFields.push(label);\n            }\n        }\n        var gcms = {};\n        gcms.gc = {};\n        gcms.ms = [];\n        for (i = 0; i < existingGCMSFields.length; i++) {\n            gcms.gc[existingGCMSFields[i]] = [];\n        }\n        for (i = 0; i < spectra.length; i++) {\n            var spectrum = spectra[i];\n            for (var j = 0; j < existingGCMSFields.length; j++) {\n                gcms.gc[existingGCMSFields[j]].push(spectrum.pageValue);\n                gcms.gc[existingGCMSFields[j]].push(parseFloat(spectrum[existingGCMSFields[j]]));\n            }\n            if (spectrum.data) gcms.ms[i] = spectrum.data[0];\n\n        }\n        result.gcms = gcms;\n    }\n\n    function prepareSpectrum(result, spectrum) {\n        if (!spectrum.xFactor) spectrum.xFactor = 1;\n        if (!spectrum.yFactor) spectrum.yFactor = 1;\n        if (spectrum.observeFrequency) {\n            if (spectrum.xUnit && spectrum.xUnit.toUpperCase() == 'HZ') {\n                spectrum.xUnit = 'PPM';\n                spectrum.xFactor = spectrum.xFactor / spectrum.observeFrequency;\n                spectrum.firstX = spectrum.firstX / spectrum.observeFrequency;\n                spectrum.lastX = spectrum.lastX / spectrum.observeFrequency;\n                spectrum.deltaX = spectrum.deltaX / spectrum.observeFrequency;\n            }\n        }\n        if (result.shiftOffsetVal) {\n            var shift = spectrum.firstX - result.shiftOffsetVal;\n            spectrum.firstX = spectrum.firstX - shift;\n            spectrum.lastX = spectrum.lastX - shift;\n        }\n    }\n\n    function parsePeakTable(spectrum, value, result) {\n        var i, ii, j, jj, values;\n        var currentData = [];\n        spectrum.data = [currentData];\n\n        // counts for around 20% of the time\n        var lines = value.split(/,? *,?[;\\r\\n]+ */);\n\n        var k = 0;\n        for (i = 1, ii = lines.length; i < ii; i++) {\n            values = lines[i].trim().replace(removeCommentRegExp, '').split(peakTableSplitRegExp);\n            if (values.length % 2 == 0) {\n                for (j = 0, jj = values.length; j < jj; j = j + 2) {\n                    // takes around 40% of the time to add and parse the 2 values nearly exclusively because of parseFloat\n                    currentData[k++] = (parseFloat(values[j]) * spectrum.xFactor);\n                    currentData[k++] = (parseFloat(values[j + 1]) * spectrum.yFactor);\n                }\n            } else {\n                result.logs.push('Format error: ' + values);\n            }\n        }\n    }\n\n    function parseXYData(spectrum, value, result) {\n        // we check if deltaX is defined otherwise we calculate it\n        if (!spectrum.deltaX) {\n            spectrum.deltaX = (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n        }\n\n        var currentData = [];\n        spectrum.data = [currentData];\n\n        var currentX = spectrum.firstX;\n        var currentY = spectrum.firstY;\n        var lines = value.split(/[\\r\\n]+/);\n        var lastDif, values, ascii, expectedY;\n        values = [];\n        for (var i = 1, ii = lines.length; i < ii; i++) {\n            //var previousValues=JSON.parse(JSON.stringify(values));\n            values = lines[i].trim().replace(removeCommentRegExp, '').split(xyDataSplitRegExp);\n            if (values.length > 0) {\n                if (DEBUG) {\n                    if (!spectrum.firstPoint) {\n                        spectrum.firstPoint = parseFloat(values[0]);\n                    }\n                    var expectedCurrentX = parseFloat(values[0] - spectrum.firstPoint) * spectrum.xFactor + spectrum.firstX;\n                    if ((lastDif || lastDif == 0)) {\n                        expectedCurrentX += spectrum.deltaX;\n                    }\n                    result.logs.push('Checking X value: currentX: ' + currentX + ' - expectedCurrentX: ' + expectedCurrentX);\n                }\n                for (var j = 1, jj = values.length; j < jj; j++) {\n                    if (j == 1 && (lastDif || lastDif == 0)) {\n                        lastDif = null; // at the beginning of each line there should be the full value X / Y so the diff is always undefined\n                        // we could check if we have the expected Y value\n                        ascii = values[j].charCodeAt(0);\n\n                        if (false) { // this code is just to check the jcamp DIFDUP and the next line repeat of Y value\n                            // + - . 0 1 2 3 4 5 6 7 8 9\n                            if ((ascii == 43) || (ascii == 45) || (ascii == 46) || ((ascii > 47) && (ascii < 58))) {\n                                expectedY = parseFloat(values[j]);\n                            } else\n                            // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n                            if ((ascii > 63) && (ascii < 74)) {\n                                // we could use parseInt but parseFloat is faster at least in Chrome\n                                expectedY = parseFloat(String.fromCharCode(ascii - 16) + values[j].substring(1));\n                            } else\n                            // negative SQZ digits a b c d e f g h i (ascii 97-105)\n                            if ((ascii > 96) && (ascii < 106)) {\n                                // we could use parseInt but parseFloat is faster at least in Chrome\n                                expectedY = -parseFloat(String.fromCharCode(ascii - 48) + values[j].substring(1));\n                            }\n                            if (expectedY != currentY) {\n                                result.logs.push('Y value check error: Found: ' + expectedY + ' - Current: ' + currentY);\n                                result.logs.push('Previous values: ' + previousValues.length);\n                                result.logs.push(previousValues);\n                            }\n                        }\n                    } else {\n                        if (values[j].length > 0) {\n                            ascii = values[j].charCodeAt(0);\n                            // + - . 0 1 2 3 4 5 6 7 8 9\n                            if ((ascii == 43) || (ascii == 45) || (ascii == 46) || ((ascii > 47) && (ascii < 58))) {\n                                lastDif = null;\n                                currentY = parseFloat(values[j]);\n                                currentData.push(currentX, currentY * spectrum.yFactor);;\n                                currentX += spectrum.deltaX;\n                            } else\n                            // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n                            if ((ascii > 63) && (ascii < 74)) {\n                                lastDif = null;\n                                currentY = parseFloat(String.fromCharCode(ascii - 16) + values[j].substring(1));\n                                currentData.push(currentX, currentY * spectrum.yFactor);;\n                                currentX += spectrum.deltaX;\n                            } else\n                            // negative SQZ digits a b c d e f g h i (ascii 97-105)\n                            if ((ascii > 96) && (ascii < 106)) {\n                                lastDif = null;\n                                currentY = -parseFloat(String.fromCharCode(ascii - 48) + values[j].substring(1));\n                                currentData.push(currentX, currentY * spectrum.yFactor);;\n                                currentX += spectrum.deltaX;\n                            } else\n\n\n\n                            // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n                            if (((ascii > 82) && (ascii < 91)) || (ascii == 115)) {\n                                var dup = parseFloat(String.fromCharCode(ascii - 34) + values[j].substring(1)) - 1;\n                                if (ascii == 115) {\n                                    dup = parseFloat('9' + values[j].substring(1)) - 1;\n                                }\n                                for (var l = 0; l < dup; l++) {\n                                    if (lastDif) {\n                                        currentY = currentY + lastDif;\n                                    }\n                                    currentData.push(currentX, currentY * spectrum.yFactor);;\n                                    currentX += spectrum.deltaX;\n                                }\n                            } else\n                            // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n                            if (ascii == 37) {\n                                lastDif = parseFloat('0' + values[j].substring(1));\n                                currentY += lastDif;\n                                currentData.push(currentX, currentY * spectrum.yFactor);;\n                                currentX += spectrum.deltaX;\n                            } else if ((ascii > 73) && (ascii < 83)) {\n                                lastDif = parseFloat(String.fromCharCode(ascii - 25) + values[j].substring(1));\n                                currentY += lastDif;\n                                currentData.push(currentX, currentY * spectrum.yFactor);;\n                                currentX += spectrum.deltaX;\n                            } else\n                            // negative DIF digits j k l m n o p q r (ascii 106-114)\n                            if ((ascii > 105) && (ascii < 115)) {\n                                lastDif = -parseFloat(String.fromCharCode(ascii - 57) + values[j].substring(1));\n                                currentY += lastDif;\n                                currentData.push(currentX, currentY * spectrum.yFactor);;\n                                currentX += spectrum.deltaX;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n    function convertTo3DZ(spectra) {\n        //console.time('ConvertTo3DZ');\n        var z = [];\n        var noise = 0;\n        var minZ = spectra[0].data[0][0];\n        var maxZ = spectra[0].data[0][0];\n        var ySize = spectra.length;\n        var xSize = spectra[0].data[0].length / 2;\n        for (var i = 0; i < ySize; i++) {\n            z[i] = [];\n            for (var j = 0; j < xSize; j++) {\n                z[i][j] = spectra[i].data[0][j * 2 + 1];\n                if (z[i][j] < minZ) minZ = spectra[i].data[0][j * 2 + 1];\n                if (z[i][j] > maxZ) maxZ = spectra[i].data[0][j * 2 + 1];\n                if (i != 0 && j != 0) {\n                    noise += Math.abs(z[i][j] - z[i][j - 1]) + Math.abs(z[i][j] - z[i - 1][j]);\n                }\n            }\n        }\n        //console.timeEnd('ConvertTo3DZ');\n        return {\n            z: z,\n            minX: spectra[0].data[0][0],\n            maxX: spectra[0].data[0][spectra[0].data[0].length - 2],\n            minY: spectra[0].pageValue,\n            maxY: spectra[spectra.length - 1].pageValue,\n            minZ: minZ,\n            maxZ: maxZ,\n            noise: noise / ((z.length - 1) * (z[0].length - 1) * 2)\n        };\n\n    }\n\n    function add2D(result) {\n        var zData = convertTo3DZ(result.spectra);\n        result.contourLines = generateContourLines(zData);\n        delete zData.z;\n        result.minMax = zData;\n    }\n\n\n    function generateContourLines(zData, options) {\n        //console.time('generateContourLines');\n        var noise = zData.noise;\n        var z = zData.z;\n        var contourLevels = [];\n        var nbLevels = 7;\n        var povarHeight = new Float32Array(4);\n        var isOver = [];\n        var nbSubSpectra = z.length;\n        var nbPovars = z[0].length;\n        var pAx, pAy, pBx, pBy;\n\n        var x0 = zData.minX;\n        var xN = zData.maxX;\n        var dx = (xN - x0) / (nbPovars - 1);\n        var y0 = zData.minY;\n        var yN = zData.maxY;\n        var dy = (yN - y0) / (nbSubSpectra - 1);\n        var minZ = zData.minZ;\n        var maxZ = zData.maxZ;\n\n        //System.out.prvarln('y0 '+y0+' yN '+yN);\n        // -------------------------\n        // Povars attribution\n        //\n        // 0----1\n        // |  / |\n        // | /  |\n        // 2----3\n        //\n        // ---------------------d------\n\n        var lineZValue;\n        for (var level = 0; level < nbLevels * 2; level++) { // multiply by 2 for positif and negatif\n            var contourLevel = {};\n            contourLevels.push(contourLevel);\n            var side = level % 2;\n            if (side == 0) {\n                lineZValue = (maxZ - 5 * noise) * Math.exp(level / 2 - nbLevels) + 5 * noise;\n            } else {\n                lineZValue = -(maxZ - 5 * noise) * Math.exp(level / 2 - nbLevels) - 5 * noise;\n            }\n            var lines = [];\n            contourLevel.zValue = lineZValue;\n            contourLevel.lines = lines;\n\n            if (lineZValue <= minZ || lineZValue >= maxZ) continue;\n\n            for (var iSubSpectra = 0; iSubSpectra < nbSubSpectra - 1; iSubSpectra++) {\n                for (var povar = 0; povar < nbPovars - 1; povar++) {\n                    povarHeight[0] = z[iSubSpectra][povar];\n                    povarHeight[1] = z[iSubSpectra][povar + 1];\n                    povarHeight[2] = z[(iSubSpectra + 1)][povar];\n                    povarHeight[3] = z[(iSubSpectra + 1)][(povar + 1)];\n\n                    for (var i = 0; i < 4; i++) {\n                        isOver[i] = (povarHeight[i] > lineZValue);\n                    }\n\n                    // Example povar0 is over the plane and povar1 and\n                    // povar2 are below, we find the varersections and add\n                    // the segment\n                    if (isOver[0] != isOver[1] && isOver[0] != isOver[2]) {\n                        pAx = povar + (lineZValue - povarHeight[0]) / (povarHeight[1] - povarHeight[0]);\n                        pAy = iSubSpectra;\n                        pBx = povar;\n                        pBy = iSubSpectra + (lineZValue - povarHeight[0]) / (povarHeight[2] - povarHeight[0]);\n                        lines.push(pAx * dx + x0, pAy * dy + y0, pBx * dx + x0, pBy * dy + y0);\n                    }\n                    if (isOver[3] != isOver[1] && isOver[3] != isOver[2]) {\n                        pAx = povar + 1;\n                        pAy = iSubSpectra + 1 - (lineZValue - povarHeight[3]) / (povarHeight[1] - povarHeight[3]);\n                        pBx = povar + 1 - (lineZValue - povarHeight[3]) / (povarHeight[2] - povarHeight[3]);\n                        pBy = iSubSpectra + 1;\n                        lines.push(pAx * dx + x0, pAy * dy + y0, pBx * dx + x0, pBy * dy + y0);\n                    }\n                    // test around the diagonal\n                    if (isOver[1] != isOver[2]) {\n                        pAx = povar + 1 - (lineZValue - povarHeight[1]) / (povarHeight[2] - povarHeight[1]);\n                        pAy = iSubSpectra + (lineZValue - povarHeight[1]) / (povarHeight[2] - povarHeight[1]);\n                        if (isOver[1] != isOver[0]) {\n                            pBx = povar + 1 - (lineZValue - povarHeight[1]) / (povarHeight[0] - povarHeight[1]);\n                            pBy = iSubSpectra;\n                            lines.push(pAx * dx + x0, pAy * dy + y0, pBx * dx + x0, pBy * dy + y0);\n                        }\n                        if (isOver[2] != isOver[0]) {\n                            pBx = povar;\n                            pBy = iSubSpectra + 1 - (lineZValue - povarHeight[2]) / (povarHeight[0] - povarHeight[2]);\n                            lines.push(pAx * dx + x0, pAy * dy + y0, pBx * dx + x0, pBy * dy + y0);\n                        }\n                        if (isOver[1] != isOver[3]) {\n                            pBx = povar + 1;\n                            pBy = iSubSpectra + (lineZValue - povarHeight[1]) / (povarHeight[3] - povarHeight[1]);\n                            lines.push(pAx * dx + x0, pAy * dy + y0, pBx * dx + x0, pBy * dy + y0);\n                        }\n                        if (isOver[2] != isOver[3]) {\n                            pBx = povar + (lineZValue - povarHeight[2]) / (povarHeight[3] - povarHeight[2]);\n                            pBy = iSubSpectra + 1;\n                            lines.push(pAx * dx + x0, pAy * dy + y0, pBx * dx + x0, pBy * dy + y0);\n                        }\n                    }\n                }\n            }\n        }\n        // console.timeEnd('generateContourLines');\n        return {\n            minX: zData.minX,\n            maxX: zData.maxX,\n            minY: zData.minY,\n            maxY: zData.maxY,\n            segments: contourLevels\n        };\n        //return contourLevels;\n    }\n\n\n    function addLowRes(spectra, options) {\n        var spectrum;\n        var averageX, averageY;\n        var targetNbPoints = options.lowRes;\n        var highResData;\n        for (var i = 0; i < spectra.length; i++) {\n            spectrum = spectra[i];\n            // we need to find the current higher resolution\n            if (spectrum.data.length > 0) {\n                highResData = spectrum.data[0];\n                for (var j = 1; j < spectrum.data.length; j++) {\n                    if (spectrum.data[j].length > highResData.length) {\n                        highResData = spectrum.data[j];\n                    }\n                }\n\n                if (targetNbPoints > (highResData.length / 2)) return;\n                var i, ii;\n                var lowResData = [];\n                var modulo = Math.ceil(highResData.length / (targetNbPoints * 2));\n                for (i = 0, ii = highResData.length; i < ii; i = i + 2) {\n                    if (i % modulo == 0) {\n                        lowResData.push(highResData[i], highResData[i + 1])\n                    }\n                }\n                spectrum.data.push(lowResData);\n            }\n        }\n    }\n\n    return convert;\n\n}\n\nvar convert = getConverter();\n\nfunction JcampConverter(input, options, useWorker) {\n    if (typeof options === 'boolean') {\n        useWorker = options;\n        options = {};\n    }\n    if (useWorker) {\n        return postToWorker(input, options);\n    } else {\n        return convert(input, options);\n    }\n}\n\nvar stamps = {},\n    worker;\n\nfunction postToWorker(input, options) {\n    if (!worker) {\n        createWorker();\n    }\n    return new Promise(function (resolve) {\n        var stamp = Date.now() + '' + Math.random();\n        stamps[stamp] = resolve;\n        worker.postMessage({stamp: stamp, input: input, options: options});\n    });\n}\n\nfunction createWorker() {\n    var workerURL = URL.createObjectURL(new Blob([\n        'var getConverter =' + getConverter.toString() + ';var convert = getConverter(); onmessage = function (event) { postMessage({stamp: event.data.stamp, output: convert(event.data.input, event.data.options)}); };'\n    ], {type: 'application/javascript'}));\n    worker = new Worker(workerURL);\n    URL.revokeObjectURL(workerURL);\n    worker.addEventListener('message', function (event) {\n        var stamp = event.data.stamp;\n        if (stamps[stamp]) {\n            stamps[stamp](event.data.output);\n        }\n    });\n}\n\nmodule.exports = {\n    convert: JcampConverter\n};\n},{}]},{},[1])(1)\n});"],"sourceRoot":"/source/"}