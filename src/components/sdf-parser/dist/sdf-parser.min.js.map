{"version":3,"sources":["sdf-parser.min.js"],"names":["e","exports","module","define","amd","f","window","global","self","SDFParser","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"parse","sdf","header","substr","crlf","indexOf","sdfPart","parts","molecule","j","jj","lines","from","to","label","k","kk","sdfParts","split","molecules","labels","start","Date","now","ii","push","molfile","type","value","substring","counter","isNumeric","isFinite","currentLabel","minValue","Number","MAX_VALUE","maxValue","MIN_VALUE","parseFloat","key","always","statistics","statistic","time","Object","keys"],"mappings":"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","file":"sdf-parser.min.js","sourcesContent":["/**\n * sdf-parser - SDF parser\n * @version v1.0.0\n * @link https://github.com/cheminfo/sdf-parser\n * @license MIT\n */\n!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.SDFParser=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\n// options: an object\n\nfunction parse(sdf, options) {\n    // we will find the delimiter in order to be much faster and not use regular expression\n    var header = sdf.substr(0, 1000);\n    var crlf = '\\n';\n    if (header.indexOf('\\r\\n') > -1) {\n        crlf = '\\r\\n';\n    } else if (header.indexOf('\\r') > -1) {\n        crlf = '\\r';\n    }\n\n    var sdfParts = sdf.split(crlf + '$$$$' + crlf);\n    var molecules = [];\n    var labels = {};\n\n    var start = Date.now();\n\n    var i = 0, ii = sdfParts.length,\n        sdfPart, parts, molecule, j, jj,\n        lines, from, to, label, k, kk;\n    for (; i < ii; i++) {\n        sdfPart = sdfParts[i];\n        parts = sdfPart.split(crlf + '>');\n        if (parts.length > 0 && parts[0].length > 5) {\n            molecule = {};\n            molecules.push(molecule);\n            molecule.molfile = {type: 'mol2d', value: parts[0] + crlf};\n            jj = parts.length;\n            for (j = 1; j < jj; j++) {\n                lines = parts[j].split(crlf);\n                from = lines[0].indexOf('<');\n                to = lines[0].indexOf('>');\n                label = lines[0].substring(from + 1, to);\n                if (labels[label]) {\n                    labels[label].counter++;\n                } else {\n                    labels[label] = {counter: 1, isNumeric: true};\n                }\n                kk = lines.length - 1;\n                for (k = 1; k < kk; k++) {\n                    if (molecule[label]) {\n                        molecule[label] += crlf + lines[k];\n                    } else {\n                        molecule[label] = lines[k];\n                    }\n                }\n                if (labels[label].isNumeric) {\n                    if (!isFinite(molecule[label])) {\n                        labels[label].isNumeric = false;\n                    }\n                }\n            }\n        }\n    }\n\n    // all numeric fields should be converted to numbers\n    var numericFields=[];\n    for (var label in labels) {\n        var currentLabel=labels[label];\n        if (currentLabel.isNumeric) {\n            currentLabel.minValue=Number.MAX_VALUE;\n            currentLabel.maxValue=Number.MIN_VALUE;\n            for (var j=0; j < molecules.length; j++) {\n                if (molecules[j][label]) {\n                    var value=parseFloat(molecules[j][label]);\n                    molecules[j][label]=value;\n                    if (value>currentLabel.maxValue) currentLabel.maxValue=value;\n                    if (value<currentLabel.minValue) currentLabel.minValue=value;\n                }\n            }\n        }\n    }\n\n    // we check that a label is in all the records\n    for (var key in labels) {\n        if (labels[key].counter==molecules.length) {\n            labels[key].always=true;\n        } else {\n            labels[key].always=false;\n        }\n    }\n\n    var statistics = [];\n    for (var key in labels) {\n        var statistic=labels[key];\n        statistic.label=key;\n        statistics.push(statistic);\n    }\n\n    return {\n        time: Date.now() - start,\n        molecules: molecules,\n        labels: Object.keys(labels),\n        statistics: statistics\n    };\n\n}\n\nmodule.exports = parse;\n\n},{}]},{},[1])(1)\n});"],"sourceRoot":"/source/"}